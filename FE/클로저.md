# 클로저란 무엇인가요?

## 1.  클로저에 대한 정의

### 1-1. MDN

**클로저**는 함수와 함수가 선언된 ***어휘적 환경의 조합으로*** -> 외부 함수의 변수에 접근할 수 있는 **내부 함수**입니다.

+ **클로저**를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지**(Lexical scoping)**를 먼저 이해해야 한다.
---
<br>


### 1-1-1. 말씀하신 어휘적 환경의 조합은 어떤 의미인가요?

어휘적 환경의 조합이란 **“변수와 함수의 선언 형태의 조합”**을 말하는 것인데요, 

자바스크립트는 함수가 호출되는 환경과는 별개로, 

기존에 선언되었던 환경을 기준으로 변수를 조회하려는 특성이 있기 때문입니다.

즉, **클로저가 생성된 시점의 유효 범위에 있는 모든 지역 변수를 사용하는 환경**을 말하는 것입니다.

---
<br>

### 1-1-2. 그러면 클로저의 특징은 무엇인가요?

**❗️ 클로저는 캡슐화와 모듈화의 특징을 가지고 있습니다.** 

1. **외부 함수의 변수가 함수 밖으로 노출되지 않아 정보의 접근을 제한**해 클로저로 자바스크립트에서 캡슐화를 구현할 수 있습니다. 
2. 또한 **클로저는 데이터를 보존하는 함수**입니다. 외부 함수의 실행이 끝나더라도 외부 함수 안의 변수가 메모리에 저장되어 값을 기억하고 있습니다. 이러한 특징으로 클로저 모듈 패턴을 구현할 수 있습니다.

---
<br>

### 1-1-3. 클로저의 단점을 설명해주실 수 있나요?

외부 함수 스코프가 내부 함수에 의해 언제든지 참조될 수 있기 때문에, **클로저 패턴은 메모리 상에 남게 됩니다.** 

이는 일반 함수였다다면 실행 종료 후 자바스크립트 메모리 관리에 의해 가비지 컬렉션이 되었을 객체가 남아있게 되는 것입니다. 

따라서 클로저를 남발할 경우 퍼포먼스 저하가 발생할 수 있다고 알고 있습니다.

---
<br>

## 1-2. 렉시컬 스코프(Lexical Scope)

함수를 어디서 호출하는지가 아니라 **어디에 선언하였는지에 따라 결정**되는 것을 말한다.

즉, 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다는 뜻이며, 가장 중요한 점은 함수의 호출이 아니라 **함수의 선언에 따라 결정된다는 점**이다.

```jsx
var x = 1; // global

function first() {
  var x = 10;
  second();
}

function second() {
  console.log(x);
}

first(); // ? -> 지수 10 : 진우 1 : 보경 10
second(); // ? -> 지수 1 : 진우 1 : 보경 1
```

위 예제의 실행 결과는 함수 **second()의 상위 스코프가 무엇인지에 따라 결정**된다.

자바스크립트는 렉시컬 스코프(Lexical Scope)를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다.

**즉, 이 말은 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다는 말이다.**

그렇기 때문에, second() 함수가 **first() 함수 안에서 호출**된 것과 상관없이 second() 함수는 **global 범위에 선언**되어 있으므로, global 범위에 있는 변수 x의 값 1이 두 번 출력된 것이다.

---

## 1-3. 클로저 예시

1. **외부 변수를 참조하는 예시**

```jsx
function func() {
  const x = 10; // 외부 변수
  return function() {
    console.log("x값은 :", x)
  }
}
const myFunc = func();

myFunc(); // x값은 : 10
```

`myFunc` 라는 변수에 `func`의 반환값인 새로운 함수를 담았다. 

그 후 호출했더니 `x`값이 없음에도 외부 변수였던 `x`를 기억하고 `10`을 보여준다.

---
<br>

2. **정보의 은닉 예시**

```jsx
function makeCounter(){
    let count = 0; // 은닉화
    return function(){
        return count++;
    }
}

let counter = makeCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

위 코드와 같이 내부에 있는 함수는 `count`를 기억하여 외부에 있는 값을 변경할 수 있습니다.
`count`의 값을 원하는 대로 바꿀 수는 없지만 하나씩 증가는 가능합니다.

---

<br>


# 최종 결론 

### **클로저** : **함수가 생성될 당시의 외부 변수를 기억하여 생성 이후에도 계속 접근 가능한 것**
